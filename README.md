# Piccolo-With-Seurat
Instructions for using Piccolo feature selection and normalization for Seurat

## Getting Started

We recommend an R version 4.2.0 or more recent in order to use the package.

### Installation

Currently, the development version of **Piccolo** can be installed using *install_github* from the **devtools** package.

Install **devtools** using:
```
install.packages("devtools",dependencies = T)
```
Once **devtools** is installed, run the following to install **Piccolo**:
```
devtools::install_github("Amartya101/Piccolo")
```
In addition to Piccolo, to use Seurat you'll need to install Seurat (v4) from CRAN:
```
install.packages("Seurat")
```
We also rely on SeuratData package for this tutorial, which can be installed from their GitHub repository ([seurat-disk](https://github.com/mojaveazure/seurat-disk)) using:
```
if (!requireNamespace("remotes", quietly = TRUE)) {
  install.packages("remotes")
}
remotes::install_github("mojaveazure/seurat-disk")
```

## Instructions for use with Seurat

The central object in the Piccolo workflow is the PiccoloList. Given the single-cell gene expression data in the .mtx or .mtx.gz format (and the corresponding features and barcodes .tsv files), we first need to create a PiccoloList that contains the matrix and the information about the features and barcodes. This can be done with the *CreatePiccoloList* function.

### CreatePiccoloList
The *CreatePiccoloList* function requires the following inputs - *MTX*, *Genes*, *Barcodes*. Assuming all the files are located in the current working directory, *MTX* should be the full name of the .mtx or .mtx.gz file that contains the gene counts. *Genes* should be the full name of the .tsv file that contains the information of the genes/features. *Barcodes* should be the full name of the .tsv file that contains the information of the barcodes. 

Here is an example of a valid function call (the 10X PBMC3k data set used as an example here can be found in the [PBMC3k_Data](https://github.com/Amartya101/PBMC3k_Data) repository):

```
pbmc3k <- CreatePiccoloList(MTX = "10X_PBMC3k_matrix.mtx.gz", Genes = "10X_PBMC3k_features.tsv", Barcodes = "10X_PBMC3k_barcodes.tsv")
```
This will create a list that contains the counts matrix, the features data frame, and the barcodes.

### FilterCells 
The *FilterCells* function is used to perform basic cell filtering based on criterias such as the minimum number of genes with non-zero counts within each cell (specified through the argument *MinFeaturesPerCell*), the maximum percentage of total counts contributed by mitochondrial genes within each cell (specified by the argument *MT.Perc*), the the maximum percentage of total counts contributed by ribosomal genes within each cell (specified by the argument *RP.Perc*), and the maximum or minimum total counts that any cell can have based on how many median absolute deviation away from the median the total count of any given cell is.

Examples of valid function calls are given below:
```
pbmc3k <- FilterCells(PiccoloList = pbmc3k)

pbmc3k <- FilterCells(PiccoloList = pbmc3k,
 MinFeaturesPerCell = 100, MT.Perc = 50,
 RP.Perc = 70,TotalCountsMADHigh = 3.5,
 TotalCountsMADLow = 3.5) #changing the filtering criteria
```
### PrepareCountsForSeurat
The *PrepareCountsForSeurat* function is simply used to format the counts matrix list item in the format that is expected by the CreateSeuratObject function of Seurat.

Example of a valid function call is given below:
```
pbmc3k <- PrepareCountsForSeurat(PiccoloList = pbmc3k)
```

### CreateSeuratObject (from Seurat package)
The *PCreateSeuratObject* function in Seurat prepares a Seurat object using a counts matrix as input.

Example of a valid function call is given below:
```
pbmc3k <- Seurat::CreateSeuratObject(counts = pbmc3k$Counts) 
#This turns PiccoloList into a Seurat object
```

### SCTransform (from Seurat package)
The *SCTransform* function in Seurat is used to prepare an SCT assay in the Seurat object, we later replace the residuals in the SCT assay with Piccolo's residuals.

Example of a valid function call is given below:
```
pbmc3k <- Seurat::SCTransform(object = pbmc3k,vst.flavor = "v2")
#This turns PiccoloList into a Seurat object
```

### SelectFeaturesForSeurat
The *SelectFeaturesForSeurat* function performs feature selection by identifying highly variable genes and stable genes. It takes in the Seurat object obtained after using the *PrepareCountsForSeurat* function as input and first performs basic gene filtering based on the criteria that at least some percentage of cells have non-zero counts for each gene (this is specified through the argument *MinPercNonZeroCells*). It then identifies highly variable genes and stable genes. You can specify the number of highly variable genes that you wish to shortlist by using the argument *NoOfHVG*. Output files containing the list of HVGs and the list of stable genes can be generated by specifying the argument *Out* to be T. 

Examples of valid function calls are given below:
```
pbmc3k <- SelectFeaturesForSeurat(Obj = pbmc3k)

pbmc3k <- SelectFeaturesForSeurat(Obj = pbmc3k,
 NoOfHVG = 3000, Out = T)
```

### NormalizeForSeurat
The *NormalizeForSeurat* function computes the residuals for the counts of the HVGs. You can specify the variance stabilization transformation that you wish to apply (default is "log") by specifying the *Transform* argument. Apart from log, options include "sqrt" (for the the square-root transform) and "bc" (for the Box-Cox power law transform). You can even generate an output file containing the residuals by specifying *Out* as T.


Examples of valid function calls are given below:
```
pbmc3k <- NormalizeForSeurat(Obj = pbmc3k)

pbmc3k <- NormalizeForSeurat(Obj = pbmc3k, Transform = "bc")
```

### Downstream analysis with Seurat

The rest of the downstream analysis - running PCA, finding nearest neighbors, identifying clusters, obtaining UMAP projections etc - can be performed using Seurat.
```
#Perform PCA
pbmc3k <- Seurat::RunPCA(pbmc3k, features = Seurat::VariableFeatures(object = pbmc3k))

#Find shared nearest neighbours and identify clusters using Louvain graph-partitioning algorithm
pbmc3k <- Seurat::FindNeighbors(pbmc3k, dims = 1:50)
pbmc3k <- Seurat::FindClusters(pbmc3k, resolution = 1)

#Obtain UMAP coordinates for the cells
pbmc3k <- Seurat::RunUMAP(pbmc3k, dims = 1:50)

Seurat::DimPlot(pbmc3k, reduction = "umap")
```
![Alt text](https://github.com/Amartya101/Piccolo-With-Seurat/blob/main/PBMC3k_PiccoloSeurat_UMAP.png)

## Instructions for use with Seurat for data integration

In order to illustrate how one can employ Piccolo to perform a data integration with Seurat, we rely on the vignette prepared for the [SCTransform v2 regularization](https://satijalab.org/seurat/articles/sctransform_v2_vignette.html). In that vignette, the SCTransform v2 based workflow was used to perform a comparative analysis of human immune cells (PBMC) in either a [resting or interferon-stimulated state](https://www.nature.com/articles/nbt.4042).

### Import data in Seurat object format (from SeuratData package)
```
ifnb <- SeuratData::LoadData("ifnb")
```
### Split data based on stimulation status
```
ifnb.list <- Seurat::SplitObject(ifnb, split.by = "stim")
```
### Use SCTransform for the data sets corresponding to the 2 conditions
```
#Create SCT assays for the list elements
ifnb.list <- lapply(X = ifnb.list, FUN = function(x) {
  x <- Seurat::SCTransform(x,vst.flavor = "v2")
})
```

### Use Piccolo to perform feature selection and normalization

```
ifnb.list <- lapply(X = ifnb.list, FUN = function(x) {
  x <- Piccolo::SelectFeaturesForSeurat(x)
})

ifnb.list <- lapply(X = ifnb.list, FUN = function(x) {
  x <- Piccolo::NormalizeForSeurat(x)
})
```

### Identify anchor features for performing integration
```
anchorfeatures <- Seurat::SelectIntegrationFeatures(object.list = ifnb.list, nfeatures = 3000)

CommonFeaturesAcrossLists <- lapply(X = ifnb.list, FUN = function(x) {
  y <- rownames(x@assays$SCT@scale.data)
  return(y)
})

CommonFeaturesAcrossLists <- Reduce(intersect,CommonFeaturesAcrossLists)

anchorfeatures <- intersect(anchorfeatures,CommonFeaturesAcrossLists)
```

### Perform data integration
```

ifnb.list <- Seurat::PrepSCTIntegration(object.list = ifnb.list, anchor.features = anchorfeatures,assay = "SCT")

immune.anchors <- Seurat::FindIntegrationAnchors(object.list = ifnb.list, normalization.method = "SCT",anchor.features = anchorfeatures)
immune.combined.sct <- Seurat::IntegrateData(anchorset = immune.anchors, normalization.method = "SCT")
```

### Perform dimensionality reduction and clustering on integrated data
```
#Run a single integrated analysis on all cells
immune.combined.sct <- Seurat::RunPCA(immune.combined.sct, verbose = FALSE)
immune.combined.sct <- Seurat::RunUMAP(immune.combined.sct, reduction = "pca", dims = 1:50, verbose = FALSE)
immune.combined.sct <- Seurat::FindNeighbors(immune.combined.sct, reduction = "pca", dims = 1:50)
immune.combined.sct <- Seurat::FindClusters(immune.combined.sct, resolution = 0.5)
```

### Visualization
To visualize the distribution of annotated celltypes across control and stimulated datasets:
```
p1 <- DimPlot(immune.combined.sct, reduction = "umap", group.by = "stim")
p2 <- DimPlot(immune.combined.sct, reduction = "umap", group.by = "seurat_clusters", label = TRUE,
    repel = TRUE)
p3 <- DimPlot(immune.combined.sct, reduction = "umap", group.by = "seurat_annotations", label = TRUE,
    repel = TRUE)
p1 | p2 | p3
```
The UMAP plots we obtain with Piccolo:
![Alt text](https://github.com/Amartya101/Piccolo-With-Seurat/blob/main/Piccolo_UMAPs.png)
For comparison, we show the UMAP plots obtained with SCTransform (v2):
![Alt text](https://github.com/Amartya101/Piccolo-With-Seurat/blob/main/SCTv2_UMAPs.png)
The cleaner separation of NK cells with Piccolo is immediately apparent.

## Authors

* **Amartya Singh** - [Amartya101](https://github.com/Amartya101/)

## License

This project is licensed under the GPL-3.0 License - see the [LICENSE.md](LICENSE.md) file for details

## Acknowledgments
* [Khiabanian Lab](https://khiabanian-lab.org)




